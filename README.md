# Дискретное преобразование Фурье
## Теоретическое введение
Природа сигнала непрерывна, но все оборудование дискретно, поэтому при любых попытках измерить сигнал, 
возможно получить только значение сигнала в какой-то момент времени. 
Однако, мы можем однозначно и без потерь оцифровать этот сигнал и получить дискретные значения в некоторых отсчетах. 
Для этого, по теореме Котельникова, необходимо получать значения сигнала с частотой,
большей или равной чем удвоенная частота оцифровываемого сигнала. 
Таким образом задача анализа сигнала с помощью преобразования Фурье сводится к 
выполнению дискретного преобразования Фурье над некоторым массивом. 
Каждый элемент массива это значение сигнала, взятое с определенной частотой дискретизации. 
С помощью этого преобразования можно перейти от стандартного временного представления к амплитудному представлению
Такое представление крайне удобно и используется в обработке сигналов. С его помощью можно разложить сложный
сигнал на набор простых гармоник, а затем обрабатывать или передавать его. 
Для возвращения к стандартному временному представлению используется формула обратного преобразования.

## Описание алгоритма дискретного преобразования Фурье

Для понимания быстрого преобразования Фурье необходимо рассказать про дискретное преобразование Фурье,
так как оба алгоритма делают одно и тоже, но дискретное преобразование гораздо проще чем быстрое,
а начинать лучше с простого. Формула прямого преобразования:

$$
X_k = \sum_{n=0}^{N-1}x_ne^\frac{-i2\pi kn}{N}
$$

Где N - количество отсчетов, а k - число в интервале от 0 до N - 1. Очевидно, что максимальное значение k равно N - 1. 
Эту формулу можно представить как 2 цикла, где внешний цикл идет по k, а внутренний по n, или так как, 
дискретное преобразование Фурье является линейным преобразованием, его можно представить как умножение вектора временных отсчетов на матрицу.
Поэтому оба цикла будут одинаковой длины, а матрица будет квадратной.

$$
{\displaystyle {\vec {X}}={\mathcal {F}}{\vec {x}}}
$$

Матрица преобразования выглядит так:    
$$
{\mathcal {F}}={\frac {1}{\sqrt {n}}}{\begin{pmatrix}1&1&1&1&\ldots &1\\1&\omega _{n}&\omega _{n}^{2}&\omega _{n}^{3}&\ldots &\omega _{n}^{n-1}\\1&\omega _{n}^{2}&\omega _{n}^{4}&\omega _{n}^{6}&\ldots &\omega _{n}^{2(n-1)}\\1&\omega _{n}^{3}&\omega _{n}^{6}&\omega _{n}^{9}&\ldots &\omega _{n}^{3(n-1)}\\\vdots &\vdots &\vdots &\vdots &\ddots &\vdots \\1&\omega _{n}^{n-1}&\omega _{n}^{2(n-1)}&\omega _{n}^{3(n-1)}&\ldots &\omega _{n}^{(n-1)^{2}}\end{pmatrix}}
$$

А элементы матрицы выглядят так:

$$
{\displaystyle {\mathcal {F}}(j,k)=\omega _{n}^{(j-1)(k-1)}, {\displaystyle \omega _{n}=e^{-{\frac {2\pi i}{n}}}}}
$$

Что можно упростить до:

$$
{\displaystyle {\mathcal {F}}(j,k)=e^{-\frac {2\pi i}{n}{(j-1)(k-1)}}}
$$

И в тригонометрическом виде:

$$
{\displaystyle {\mathcal {F}}(j,k).re=xcos(\frac{2\pi k n}{N})}
$$
$$
{\displaystyle {\mathcal {F}}(j,k).im=-xsin(\frac{2\pi k n}{N})}
$$

Так как в *c++* нет представления мнимого числа по умолчанию, в код будет использоваться тригонометрическое представления комплексного числа,
т.е для расчета действительной части комплексного числа будет использоваться $cos(2\pi n)$, а для мнимой части $sin(2\pi n)$. 
### Программная реализация дискретного преобразования Фурье на языке c++ 
Теперь, когда понятен механизм рассчета, можно привести код.  
В стандартной библиотеке c++ вектором обозначается массив, т.е все его элементы располагаются в памяти последовательно, 
что обеспечивает скорость работы. Класс complex является самописным для удобства работы.

```c++
// Функция вернет вектор комлексных чисел
// Функция принимает константную ссылку на вектор беззнаковых 64 битных чисел
std::vector<complex> DFT(const std::vector<uint64_t>& x)
{
    std::vector<complex> X; // Создаем вектор 
    X.reserve(x.size()); // Резервируем память заранее, что бы не перевыделять ее в процессе работы программы несколько раз

    // Внешний цикл
    for (uint64_t k = 0; k < x.size(); ++k)
    {
        complex step; // Комплексное число, для добавления в вектор результата
        for (uint64_t n = 0; n < x.size(); ++n) // Внутренний цикл
        {
            step.Re += x[n] * cos((2 * PI * k * n) / x.size()); // Рассчет действительной части комплексного числа
            step.Im -= x[n] * sin((2 * PI * k * n) / x.size()); // Рассчет мнимой части комплексного числа
        }
        X.emplace_back(step); // Добавление нового элемента в конец вектора
    }
    return X; // Возвращение результата операции
}
```

С помощью данного кода можно провести прямое дискретное преобразование Фурье и получить массив комплексных чисел. 

### Обратное дискретное преобразование Фурье
Формула обратного преобразовния

$$
x_n = \frac{1}{N} \sum_{k=0}^{N-1}X_ke^\frac{i2\pi kn}{N}
$$

С ее помощью можно вернуться из частотного представления в временное.

### Описание алгоритма быстрого преобразования Фурье
Быстрое преобразование Фурье — это метод, позволяющий вычислять дискретное преобразование Фурье за время $O(nlog n)$

Проблема дискретного преобразования Фурье заключается в повторных вычеслениях. Для демонстрации можно привести матрицу дискретного преобразования

$$
{\mathcal {F}}={\frac {1}{\sqrt {n}}}{\begin{pmatrix}1&1&1&1&\ldots &1\\1&\omega _{n}&\omega _{n}^{2}&\omega _{n}^{3}&\ldots &\omega _{n}^{n-1}\\1&\omega _{n}^{2}&\omega _{n}^{4}&\omega _{n}^{6}&\ldots &\omega _{n}^{2(n-1)}\\1&\omega _{n}^{3}&\omega _{n}^{6}&\omega _{n}^{9}&\ldots &\omega _{n}^{3(n-1)}\\\vdots &\vdots &\vdots &\vdots &\ddots &\vdots \\1&\omega _{n}^{n-1}&\omega _{n}^{2(n-1)}&\omega _{n}^{3(n-1)}&\ldots &\omega _{n}^{(n-1)^{2}}\end{pmatrix}}
$$

Как можно заметить, в матрице присутствуют одинаковые элементы, например $\omega_n^2$ или же $\omega_n^2$. 
Дискретное преобразование Фурье считает одни и те же данные очень много раз, а быстрое преобразование позволяет избежать повторных расчетов,
за счет чего можно ускорить вычисления с $O(n^2)$ до $O(nlogn)$.
Главной идеей быстрого преобразования Фурье является уменьшение количества расчетов, за счет чего удается снизить сложность алгоритма, 
а соответсвенно и время выполения программы. Это уменьшение происходит из-за рекурсии. Алгоритм делит исходный массив, 
на два равных массива и вызывает для каждого из них себя же, пока не дойдет до массива длины 1. После этого на каждом шаге рекурсии
будет выполняться цикл, добавляющий коэффициенты из дискретного преобразования.
Алгоритм имеет и другие оптимизации, ускоряющие его, например перестановка элементов и отказ от рекурсии. 
Также существуют аппаратные оптимизации и оптимизации языка программирования, 
благодаря ним тоже удается ускорить работу программы. Под аппаратными оптимизациями я имею ввиду использование векторизованных расчетов, 
с помощью SSE или AVX инструкций.

### Реализация быстрого преобразования Фурье на c++
Данная функция реализует быстрое преобразование Фурье, без использования каких либо дополнительных оптимизаций и не рекомендуется
к использованию, так как следующая реализация во всем лучше этой.

```c++
// Данная функция ничего не возвращает, а результат будет записан в a
void FFT(std::vector<complex>& a) 
{
	int n = (int)a.size(); // Определение длины массива
	if (n == 1) return; // Если длина массива равна 1, то начинаем выход из рекурсии
 
	std::vector<complex> a0(n/2),  a1(n/2); // Два массива в два раза меньше чем массив функции, передающиеся в рекурсию
	for (int i=0, j=0; i<n; i+=2, ++j) // Заполнение двух массивов. В a0 идут четные, в a1 идут нечетные
    {
		a0[j] = a[i];
		a1[j] = a[i+1];
	}

	fft (a0); // Вызываем эту же функцию для половины массива
	fft (a1); // Выйдем из этих функций, когда в a0 и a1 будет лежать по одному элементу
 
	double ang = 2 * PI / n ; // Считаем коэффициент
	complex w(1), wn(cos(ang), sin(ang)); // Создаем два комплексных числа
	for (int i = 0; i < n / 2; ++i) // Проходим по всем внутренним массивам рекурсии
    {
		a[i] = a0[i] + w * a1[i];
		a[i + n / 2] = a0[i] - w * a1[i];
		w *= wn;
	}
}
```

Данная реализация сокращает количество операций с $N^2$ до $NlogN$

### Улучшенная реализация быстрого преобразования Фурье на c++

```c++
template <class T>
std::vector<complex> FFT(const std::vector<T>& x)
{
    const int64_t recursiveLen = ceil(log2(x.size()));
    const int64_t arrLen = pow(2, recursiveLen);

    // Make vector length a multiple of the power of two
    std::vector<complex> res(arrLen - x.size());
    res.insert(res.end(), x.begin(), x.end());

    // Swap by reverse bit elements
    for (int64_t i = 0; i < arrLen; ++i)
    {
        int64_t newPos = InverseNumber(i, recursiveLen);

        if (i < newPos && newPos != i)
        {
            complex srcVal = res[i];
            res[i] = res[newPos];
            res[newPos] = srcVal;
        }
    }

    int64_t halfElem = arrLen / 8;
    std::vector<complex> tmp(arrLen);
    std::vector<complex> w(arrLen / 2);

    // Pre calculate constans W in complex circle
    // Calculate 0 value
    w[0].Re = 1;
    w[0].Im = 0;

    // Calculate middle value
    w[arrLen / 4].Re = cos(2 * PI * (arrLen / 4) / arrLen);
    w[arrLen / 4].Im = -sin(2 * PI * (arrLen / 4) / arrLen);

    // First and fourth quad
    //         |   x = 1
    //         |  
    //    -----------
    //         |
    //         |   x = 4
    for (int64_t i = 1; i <= halfElem; ++i)
    {
        // 1 quad
        w[i].Re = cos(2 * PI * i / arrLen);
        w[i].Im = -sin(2 * PI * i / arrLen);

        // 4 quad
        w[w.size() - i].Re = -w[i].Re;
        w[w.size() - i].Im = w[i].Im;
    }

    // Second and third quad
    // 2 = x   |   
    //         |  
    //    -----------
    //         |
    // 3 = x   |   
    for (int64_t i = 1; i < halfElem; ++i)
    {
        // 2 quad
        w[halfElem + i].Re = -w[(halfElem - i) % halfElem].Im;
        w[halfElem + i].Im = -w[(halfElem - i) % halfElem].Re;

        // 3 quad
        w[w.size() - 2 * halfElem + i].Re = w[i].Im;
        w[w.size() - 2 * halfElem + i].Im = -w[i].Re;
    }

    int64_t elemCount = 2;
    // Recursion cycle
    for (int64_t i = 0; i < recursiveLen; ++i)
    {
        // Calculate array with w
        halfElem = elemCount / 2;

        // Iterate over all array by chunks with elemCount
        for (int64_t j = 0; j < arrLen; j += elemCount)
        {
            for (int64_t k = 0; k < halfElem; ++k)
            {
                tmp[j + k] = res[j + k] + w[k * (arrLen / elemCount)] * res[j + k + halfElem];
                tmp[j + halfElem + k] = res[j + k] - w[k * (arrLen / elemCount)] * res[j + k + halfElem];
            }
        }

        res = tmp;
        elemCount <<= 1;
    }

    return res;
}
```

Также существует реализация через модульную арифметику, она работает медленнее, но не имеет погрешности